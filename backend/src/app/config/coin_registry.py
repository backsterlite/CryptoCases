# from __future__ import annotations
# import json
# from pathlib import Path
# from typing import Dict, Optional, NoReturn, List
# from app.models.coin_registry import NormalizedCoin, NetworkEntry, DecimalEntry


# class CoinRegistry:
#     _registry: Dict[str, NormalizedCoin] = {}

#     @classmethod
#     def load_from_file(cls, path: Path) -> None:
#         with open(path, "r") as f:
#             raw_data = json.load(f)

#         cls._registry = cls._parse(raw_data)
        
#     @classmethod
#     def _parse(cls, raw_data) -> Dict[str,NormalizedCoin]:
#         parsed = {}
#         for coin_id, entry in raw_data.items():
#             parsed[coin_id.upper()] = NormalizedCoin(
#                 coin_symbol=entry["coin_symbol"],
#                 coin_name=entry["coin_name"],
#                 coin_thumb=entry.get("coin_thumb"),
#                 coin_contract_addresses={
#                     code: NetworkEntry(**net)
#                     for code, net in entry["coin_contract_addresses"].items()
#                 },
#                 coin_decimals={
#                     code: DecimalEntry(**dec)
#                     for code, dec in entry["coin_decimals"].items()
#                 },
#                 coingecko_id=entry["coingecko_id"],
#                 is_native=entry["is_native"],
#                 native_network=entry["native_network"]
#             )
#         return parsed
    
#     @classmethod
#     def get(cls, coin_id: str) -> Optional[NormalizedCoin]:
#         return cls._registry.get(coin_id.upper())

#     @classmethod
#     def get_contract(cls, coin_id: str, network: str) -> Optional[str]:
#         coin = cls.get(coin_id)
#         if not coin:
#             return None
#         entry = coin.coin_contract_addresses.get(network.upper())
#         return entry.contract if entry else None

#     @classmethod
#     def get_decimals(cls, coin_id: str, network: str) -> Optional[int]:
#         coin = cls.get(coin_id)
#         if not coin:
#             return None
#         entry = coin.coin_decimals.get(network.upper())
#         return entry.decimal_place if entry else None

#     @classmethod
#     def is_supported(cls, coin_id: str, network: str) -> bool:
#         coin = cls.get(coin_id)
#         return network.upper() in coin.coin_contract_addresses if coin else False

#     @classmethod
#     def get_runtime(cls, coin_id: str) -> Optional["Coin"]: # type: ignore  # noqa: F821
#         from app.models.coin import Coin
        
#         normalize_coin = cls.get(coin_id)
#         if not normalize_coin:
#             return None
        
#         coin = Coin.from_registry(normalize_coin)
#         return coin
    
#     @classmethod
#     def get_ids(cls) -> Optional[List[str]]:
#         if CoinRegistry._registry:
#             return [key.lower() for key in CoinRegistry._registry.keys()]
#         return []
        

"""CoinRegistry â€“ meta information only (symbol, name, thumb, aliases, native).

Loads **data/coin_registry.json** (generated by build_coin_registry.py).
"""
from __future__ import annotations

import json
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass

@dataclass(slots=True)
class CoinMeta:
    symbol: str
    name: str
    thumb: Optional[str]
    coingecko_id: str
    aliases: List[str]
    is_native: bool
    native_network: Optional[str]

class CoinRegistry:
    _coins: Dict[str, CoinMeta] = {}

    # ------------------------------------------------------------------
    # Loader
    # ------------------------------------------------------------------
    @classmethod
    def load_from_file(cls, path: Path | str) -> None:
        raw = json.loads(Path(path).read_text(encoding="utf-8"))
        cls._coins = {
            cid: CoinMeta(
                symbol=entry["symbol"],
                name=entry["name"],
                thumb=entry.get("thumb"),
                coingecko_id=entry["coingecko_id"],
                aliases=[a.upper() for a in entry.get("aliases", [])],
                is_native=bool(entry["is_native"]),
                native_network=(entry["native_network"].upper() if entry["native_network"] else None),
            )
            for cid, entry in raw.items()
        }

    # ------------------------------------------------------------------
    # Access
    # ------------------------------------------------------------------
    @classmethod
    def get(cls, coin_id: str) -> Optional[CoinMeta]:
        key = coin_id.upper()
        if key in cls._coins:
            return cls._coins[key]
        # try aliases
        for meta in cls._coins.values():
            if key in meta.aliases:
                return meta
        # try coingecko_id
        for key, value in cls._coins.items():
            if key == value.coingecko_id:
                return value
        return None

    @classmethod
    def list_ids(cls) -> List[str]:
        return [coin_meta.coingecko_id for _, coin_meta in cls._coins.items()]

    # Debug ------------------------------------------------------------
    @classmethod
    def __repr__(cls) -> str:  # pragma: no cover
        return f"CoinRegistry(coins={len(cls._coins)})"

